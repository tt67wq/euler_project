/*
 * =====================================================================================
 *
 *       Filename:  karastuba.c
 *
 *    Description:  大数相乘，karastuba算法简单描述，分治法的典型应用
 *
 *        Version:  1.0
 *        Created:  2018-01-20
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  wanqiang
 *
 * =====================================================================================
 */

/* http://blog.csdn.net/bjarnecpp/article/details/77435847 */
#include <stdio.h>
#include <stdlib.h>

#define LENGTH(a) ((sizeof(a)) / (sizeof(a[0])))
#define TRUE 1
#define FALSE 0
#define N 32
#define CARRYNUM 0x100

typedef unsigned char u8;
typedef unsigned int u32;

void BigMul(u8 *res_high, u8 *res_low, u8 *a, u8 *b) {
	int ai, bi, ri;
	u32 tmp;
	u32 res[N * 2] = {0};

	// 核心部分
        for (ai = N - 1; ai >= 0; ai--) { // 从低到高
		for (bi = N - 1; bi >= 0; bi--) {
			tmp = a[ai] * b[bi];
			res[ai + bi + 1] += (tmp % CARRYNUM);
			res[ai + bi] += (tmp / CARRYNUM);
		}
	}
	for (ri = (2 * N) - 1; ri > 0; ri--) {
		if (res[ri] > CARRYNUM - 1) {
			res[ri - 1] += (res[ri] / CARRYNUM); // 进位
			res[ri] = res[ri] % CARRYNUM;
		}
	}

	// 输出
	for (ri = 0; ri < 2 * N; ri++) {
		if (ri < N)
			res_high[ri] = res[ri];
		else
			res_low[ri - N] = res[ri];
	}
	return;
}

void print_num(u8 *res_high, u8 *res_low) {
	int i = 0;
	for (i = 0; i < N; i++) {
		printf("%02x", res_high[i]);
	}

	for (i = 0; i < N; i++) {
		printf("%02x", res_low[i]);
	}
}

int main() {
	//数组[0]数据高位, [31]数据低位
	// u8 a[N] =
	// {0xDE,0x2A,0x7C,0xF8,0x48,0x24,0xCF,0xA0,0xCE,0xD7,0x16,0xAD,0xF5,0xD4,0x7D,0xE9,0x3D,0xFA,0x31,0xEB,0x69,0x26,0xB7,0xF7,0xDF,0x69,0xBD,0xE0,0x1F,0x9E,0xDB,0x0D};
	// u8 b[N] =
	// {0x5A,0x1C,0x23,0x99,0x87,0x70,0x82,0xB8,0x12,0x50,0xCB,0x2A,0x7F,0x8B,0x74,0x53,0x5D,0x38,0x05,0xB5,0xB0,0xFE,0x8C,0x0E,0xF1,0xE7,0x73,0x15,0x47,0xD4,0x9A,0xA2};

	// u8 a[N] =
	// {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
	// u8 b[N] =
	// {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

	// u8 a[N] =
	// {0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};
	// u8 b[N] =
	// {0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};

	// u8 a[N] =
	// {0x00,0x00,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};
	// u8 b[N] =
	// {0x00,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};

	u8 a[N] = {0x00, 0x00, 0x00, 0xD1, 0xB8, 0xAA, 0x3E, 0x1B, 0x32, 0xDB, 0xB9,
		   0x5A, 0x13, 0xB3, 0x52, 0x79, 0x10, 0x22, 0x1E, 0x47, 0x49, 0x00,
		   0x8D, 0xF9, 0xA3, 0x40, 0xE6, 0x9D, 0x68, 0x38, 0x2C, 0x58};
	u8 b[N] = {0x00, 0x00, 0x00, 0x00, 0x00, 0xBF, 0xB7, 0x4C, 0x0C, 0xBF, 0x09,
		   0x13, 0x1E, 0x1E, 0xEC, 0x72, 0x21, 0x60, 0xE5, 0x5F, 0xAD, 0xCF,
		   0x8E, 0x50, 0x50, 0xE7, 0xBA, 0xF5, 0xE9, 0x6B, 0x3D, 0x5E};

	u8 res_high[N] = {0};
	u8 res_low[N] = {0};
	int i = 0;

	BigMul(res_high, res_low, a, b);

	print_num(res_high, res_low);
	return 1;
}
